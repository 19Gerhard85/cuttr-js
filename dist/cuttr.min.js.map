{"version":3,"sources":["cuttr.js"],"names":["root","define","amd","factory","module","exports","Cuttr","this","el","options","self","Object","create","prototype","originalContent","document","querySelectorAll","contentVisibilityState","contentTruncationState","truncate","length","ending","loadedClass","readMore","readMoreText","readLessText","readMoreBtnTag","afterExpand","readMoreBtnAdditionalClasses","keys","forEach","key","truncateIt","thisElement","str","thisIndex","dataset","cuttrIndex","substring","cuttrMethod","words","split","splice","join","sentences","match","currentElement","btnAdditionalClasses","nextElementSibling","btnPosition","addReadMore","updated","cuttrReadmore","cuttrReadless","cuttrReadmorePosition","readMoreBtnPosition","addEventListener","cuttrReadmoreTag","event","target","classList","contains","updateContent","cuttrReadmoreAdditionalClasses","btnText","btnMarkup","btnTag","readMoreBtnSelectorClass","replace","btnExists","matches","btnSelectorClass","querySelector","insertAdjacentHTML","previousElementSibling","truncateLength","console","truncatedContent","parentNode","displayWarnings","isAuthorized","innerHTML","cuttrLength","truncateEnding","cuttrEnding","currentContent","trim","thisBtnPosition","afterTruncate","call","expandContent","selector","currentElements","elementsToTruncate","i","showError","type","text","window","truncateContent","removeChild","each","e","destroy","remove","removeAttribute","dataIndex","RegExp","test","domain","indexOf","prepare","contentToTitle","cuttrTitle","title","setAttribute","init","jQuery","$","fn","element","extend","data","log"],"mappings":"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","file":"cuttr.min.js","sourcesContent":["/*!\n * Cuttr 1.4.0\n * https://github.com/d-e-v-s-k/cuttr-js\n *\n * @license GPLv3 for open source use only\n * or Cuttr Commercial License for commercial use\n * https://cuttr.kulahs.de/pricing/\n *\n * Copyright (C) 2022 https://cuttr.kulahs.de/ - A project by DEVSK\n **/\n\n(function (root, factory) {\n    if (typeof define === 'function' && define.amd) {\n        // AMD. Register as an anonymous module.\n        define([], factory);\n    } else if (typeof module === 'object' && module.exports) {\n        // Node. Does not work with strict CommonJS, but\n        // only CommonJS-like environments that support module.exports,\n        // like Node.\n        module.exports = factory();\n    } else {\n        // Browser globals (root is window)\n        root.Cuttr = factory();\n    }\n}(this, function () {\n    const Cuttr = function (el, options){\n        'use strict';\n\n        const self = Object.create(Cuttr.prototype);\n\n        /**\n         * Default settings\n         */\n        self.options = {\n            //  global data\n            elementsToTruncate:  typeof el === 'string' ? document.querySelectorAll(el) : el,\n            originalContent: [],\n            contentVisibilityState: [],\n            contentTruncationState: [],\n\n            //  set default options\n            truncate: 'characters', // truncate method [characters|words|sentences]\n            length: 100,  //  truncation limit\n            ending: '...',    //  truncation ending string\n            loadedClass: 'cuttr--loaded', //  class to set when truncation finished\n            title: false,    //  add original content to elements title tag\n            readMore: false, // read more button enabled/disabled\n            readMoreText: 'read more',\n            readLessText: 'read less',\n            readMoreBtnPosition: 'after',  // [after|inside]\n            readMoreBtnTag: 'button', //  read-more button tag [button|a|...]\n            readMoreBtnSelectorClass: 'cuttr__readmore', //  read-more button selector\n            readMoreBtnAdditionalClasses: '',\n\n            //  callback functions\n            afterTruncate: function(){},\n            afterExpand: function(){},\n\n            //  private options\n            dataIndex: 'data-cuttr-index',   // cuttr index data attribute\n        };\n\n        /**\n         * User defined options\n         */\n        if (options) {\n            Object.keys(options).forEach(function (key){\n                self.options[key] = options[key];\n            });\n        }\n\n\n        const init = function () {\n            prepare.call(this);\n        };\n\n\n        /*\n            prepare cuttable elements\n         */\n        function prepare() {\n\n            const isAuthorized = self.options && new RegExp('([\\\\d\\\\w]{8}-){3}[\\\\d\\\\w]{8}|^(?=.*?[A-Y])(?=.*?[a-y])(?=.*?[0-8])(?=.*?[#?!@$%^&*-]).{8,}$').test(self.options['li'+'cen'+'seK' + 'e' + 'y']) || document.domain.indexOf('cuttr'+'.' +'kul' + 'ahs' + '.' + 'de') > -1;\n\n            //  return if no target element defined\n            if (!self.options.elementsToTruncate) {\n                return;\n            } else {\n                displayWarnings(isAuthorized);\n            }\n\n            //  set element type depending on source\n            if ( !('length' in self.options.elementsToTruncate) )\n                self.options.elementsToTruncate = [self.options.elementsToTruncate];\n\n            //  loop through target elements to truncate\n            for (let i = 0; i < self.options.elementsToTruncate.length; i++) {\n\n                const currentElement  = self.options.elementsToTruncate[i];\n                const currentContent  = currentElement.innerHTML;\n                const truncateLength  = (currentElement.dataset.cuttrLength) ? currentElement.dataset.cuttrLength : self.options.length;\n                const truncateEnding  = (currentElement.dataset.cuttrEnding) ? currentElement.dataset.cuttrEnding : self.options.ending;\n                const contentToTitle  = (currentElement.dataset.cuttrTitle) ? currentElement.dataset.cuttrTitle : self.options.title;\n                let truncatedContent;\n\n                //  add truncate-element index to element\n                currentElement.setAttribute(self.options.dataIndex, i);\n\n                //  temporary save elements original content\n                self.options.originalContent.push(currentContent);\n\n                //  truncate content\n                truncatedContent = truncateIt(currentElement, currentContent.trim(), truncateLength, truncateEnding);\n\n                //  set title attr with original text content\n                if (contentToTitle)\n                    currentElement.title = currentElement.textContent.trim();\n\n                //  set new content\n                currentElement.innerHTML = truncatedContent;\n\n                //  add read-more button if current content is truncated\n                if (self.options.contentTruncationState[i]) {\n\n                    if (self.options.readMore)\n                        addReadMore(currentElement);\n\n                    currentElement.classList += ' ' + self.options.loadedClass;\n\n                }\n\n                //  here go the callbacks\n                self.options.afterTruncate.call(currentElement);\n\n            }\n\n        }\n\n\n        /*\n            truncate text to specific length\n        */\n        function truncateIt(thisElement, str, length, ending) {\n\n            const thisIndex       = thisElement.dataset.cuttrIndex;\n            const truncateMethod  = (thisElement.dataset.cuttrMethod) ? thisElement.dataset.cuttrMethod : self.options.truncate;\n\n            //  set defaults\n            if (length == null) {\n                length = 100;\n            }\n\n            //  set defaults\n            if (ending == null) {\n                ending = '...';\n            }\n\n            //  truncate content based on method\n            switch (truncateMethod) {\n\n                //  truncate characters only\n                case 'characters':\n\n                    //  check if content (string) is longer than truncation limit\n                    if (str.length > length) {\n\n                        //  set current content truncation true and return truncated string\n                        self.options.contentTruncationState[thisIndex] = true;\n                        //  set visibility state\n                        self.options.contentVisibilityState[thisIndex] = false;\n\n                        //  return new string\n                        return str.substring(0, length - ending.length) + ending + ' ';\n\n                    } else {\n                        return str;\n                    }\n\n                    break;\n\n                //  truncate words\n                case 'words':\n\n                    const words = str.split(/ (?=[^>]*(?:<|$))/);\n\n                    //  check if content (string) is longer than truncation limit\n                    if (words.length > length) {\n\n                        //  set current content truncation true and return truncated string\n                        self.options.contentTruncationState[thisIndex] = true;\n                        //  set visibility state\n                        self.options.contentVisibilityState[thisIndex] = false;\n                        //  return new string\n                        //  split spaces followed by sequence of characters are NOT greater-than signs, less-than sign\n                        return words.splice(0,length).join(' ') + ' ' + ending + ' ';\n\n                    } else {\n                        return str;\n                    }\n\n                    break;\n\n                //  truncate full sentences\n                case 'sentences':\n\n                    const sentences = str.match(/[^\\.!\\?]+[\\.!\\?]+/g);\n\n                    //  check if content (string) is longer than truncation limit\n                    if (sentences.length > length) {\n\n                        //  set current contetn truncation true and return truncated string\n                        self.options.contentTruncationState[thisIndex] = true;\n                        //  set visibility state\n                        self.options.contentVisibilityState[thisIndex] = false;\n                        //  return new string\n                        return sentences.splice(0,length).join(' ') + ' ' + ending + ' ';\n\n                    } else {\n                        return str;\n                    }\n\n                    break;\n\n                //  truncate characters by default\n                default:\n\n                    //  check if content (string) is longer than truncation limit\n                    if (str.length > length) {\n\n                        //  set current contetn truncation true and return truncated string\n                        self.options.contentTruncationState[thisIndex] = true;\n                        //  set visibility state\n                        self.options.contentVisibilityState[thisIndex] = false;\n                        //  return new string\n                        return str.substring(0, length - ending.length) + ending;\n\n                    } else {\n                        return str;\n                    }\n\n            }\n\n        }\n\n\n        /*\n            append read more button\n        */\n        function addReadMore(thisElement, updated) {\n\n            const currentElement      = thisElement;\n            const thisIndex           = currentElement.dataset.cuttrIndex;\n            const readMoreText        = (currentElement.dataset.cuttrReadmore) ? currentElement.dataset.cuttrReadmore : self.options.readMoreText;\n            const readLessText        = (currentElement.dataset.cuttrReadmore) ? currentElement.dataset.cuttrReadless : self.options.readLessText;\n            const btnPosition         = (currentElement.dataset.cuttrReadmorePosition) ? currentElement.dataset.cuttrReadmorePosition : self.options.readMoreBtnPosition;\n            const btnTag              = (currentElement.dataset.cuttrReadmoreTag) ? currentElement.dataset.cuttrReadmoreTag : self.options.readMoreBtnTag;\n            const btnSelectorClass    = '.' + self.options.readMoreBtnSelectorClass;\n            const btnAdditionalClasses = (currentElement.dataset.cuttrReadmoreAdditionalClasses) ? currentElement.dataset.cuttrReadmoreAdditionalClasses : self.options.readMoreBtnAdditionalClasses;\n            const btnText             = (self.options.contentVisibilityState[thisIndex]) ? readLessText : readMoreText;\n            const btnAriaExpanded     = (self.options.contentVisibilityState[thisIndex]) ? 'true' : 'false';\n            const btnMarkup           = ' <' + btnTag + ' aria-expanded=\"' + btnAriaExpanded + '\" class=\"' + self.options.readMoreBtnSelectorClass + ' ' + btnAdditionalClasses + '\">' + btnText.replace(/<[^>]*>/g, \"\") + '</' + btnTag + '>';\n            let btnExists;\n\n            //  check for button existence depending on btn position\n            if (btnPosition == 'after' && currentElement.nextElementSibling) {\n                btnExists = currentElement.nextElementSibling.matches(btnSelectorClass);\n            } else if (btnPosition == 'inside') {\n                btnExists = currentElement.querySelector(btnSelectorClass);\n            }\n\n            //  insert element only if it doesn't exist\n            if (!btnExists) {\n\n                //  add read-more button to dom\n                switch (btnPosition) {\n                    case 'after':\n                        currentElement.insertAdjacentHTML('afterend', btnMarkup);\n                        break;\n                    case 'inside':\n                        currentElement.insertAdjacentHTML('beforeend', btnMarkup);\n                        break;\n                    default:\n                        console.log('no matching read-more button position defined');\n                }\n\n                //  listen to read-more clicks - show/hide content\n                if (!updated) {\n\n                    if (btnPosition == 'after') {\n                        currentElement.nextElementSibling.addEventListener('click',function(event) {\n                            if (event.target && event.target.classList.contains(self.options.readMoreBtnSelectorClass)) {\n                                updateContent(event, btnPosition);\n                            }\n                        });\n                    } else if (btnPosition == 'inside') {\n                        currentElement.addEventListener('click',function(event) {\n                            if (event.target && event.target.classList.contains(self.options.readMoreBtnSelectorClass)) {\n                                updateContent(event, btnPosition);\n                            }\n                        });\n                    }\n\n                }\n\n            }\n\n        }\n\n\n        /*\n            display original/truncated content\n        */\n        function updateContent(event, btnPosition) {\n\n            const currentElement      = (btnPosition == 'after') ? event.target.previousElementSibling : event.target.parentNode;\n            const currentContent      = currentElement.innerHTML;\n            const thisIndex           = currentElement.dataset.cuttrIndex;\n            const readMoreText        = (currentElement.dataset.cuttrReadmore) ? currentElement.dataset.cuttrReadmore : self.options.readMoreText;\n            const readLessText        = (currentElement.dataset.cuttrReadmore) ? currentElement.dataset.cuttrReadless : self.options.readLessText;\n            const truncateLength      = (currentElement.dataset.cuttrLength) ? currentElement.dataset.cuttrLength : self.options.length;\n            const truncateEnding      = (currentElement.dataset.cuttrEnding) ? currentElement.dataset.cuttrEnding : self.options.ending;\n            let truncatedContent;\n\n            //  show content if its currently truncated\n            if (!self.options.contentVisibilityState[thisIndex]) {\n\n                //  replace content with original content from element at specific index\n                currentElement.innerHTML = self.options.originalContent[thisIndex];\n\n                //  set visibility state\n                self.options.contentVisibilityState[thisIndex] = true;\n\n                if (btnPosition == 'inside' && self.options.readMore)\n                    addReadMore(currentElement, true);\n\n                //  update button text and aria\n                event.target.innerHTML = readLessText.replace(/<[^>]*>/g, \"\");\n                //event.target.setAttribute('aria-expanded', 'true');\n\n                //  here go the callbacks\n                self.options.afterExpand.call(currentElement);\n\n            //  truncate content if its shown completely currently\n            } else {\n\n                //  truncate content\n                truncatedContent = truncateIt(currentElement, currentContent.trim(), truncateLength, truncateEnding);\n                currentElement.innerHTML = truncatedContent;\n\n                //  set visibility state\n                self.options.contentVisibilityState[thisIndex] = false;\n\n                if (btnPosition == 'inside' && self.options.readMore)\n                    addReadMore(currentElement, true);\n\n                //  update button text and aria\n                event.target.innerHTML = readMoreText.replace(/<[^>]*>/g, \"\");\n                //event.target.setAttribute('aria-expanded', 'false');\n\n                //  here go the callbacks\n                self.options.afterTruncate.call(currentElement);\n\n            }\n\n        }\n\n\n        /**\n         * Displays warnings\n         */\n        function displayWarnings(isAuthorized) {\n\n            if (!isAuthorized) {\n                showError('error', 'Cuttr.js has a GPLv3 license and it requires a `licenseKey` option. Read about it here:');\n                showError('error', 'https://github.com/d-e-v-s-k/cuttr-js#options');\n            }\n\n        }\n\n\n        /*\n            public function\n            expand / show original content\n        */\n        self.expandContent = function(selector, btnPosition) {\n\n            let currentElements;\n\n            //  set specific element to expand or use current instance node\n            if (selector) {\n                currentElements = document.querySelectorAll(selector);\n            } else {\n                currentElements = self.options.elementsToTruncate;\n            }\n\n            for (let i = 0; i < currentElements.length; i++) {\n\n                const currentElement      = currentElements[i];\n                const currentContent      = currentElement.innerHTML;\n                const thisIndex           = currentElement.dataset.cuttrIndex;\n                const readLessText        = (currentElement.dataset.cuttrReadmore) ? currentElement.dataset.cuttrReadless : self.options.readLessText;\n                const thisBtnPosition     = (btnPosition) ? btnPosition : self.options.readMoreBtnPosition;\n                const btnSelectorClass    = '.' + self.options.readMoreBtnSelectorClass;\n                let btnExists;\n\n                //  show content if its currently truncated\n                if (!self.options.contentVisibilityState[thisIndex]) {\n\n                    //  replace content with original content from element at specific index\n                    currentElement.innerHTML = self.options.originalContent[thisIndex];\n\n                    //  set visibility state\n                    self.options.contentVisibilityState[thisIndex] = true;\n\n                    //  read-more handling only if enabled\n                    if (self.options.readMore) {\n\n                        if (thisBtnPosition == 'inside')\n                            addReadMore(currentElement, true);\n\n                        //  check for button existence depending on btn position\n                        if (thisBtnPosition == 'after') {\n                            btnExists = currentElement.nextElementSibling;\n                        } else if (thisBtnPosition == 'inside') {\n                            btnExists = currentElement.querySelector(btnSelectorClass);\n                        }\n\n                        //  update button text\n                        if(btnExists)\n                            btnExists.innerHTML = readLessText.replace(/<[^>]*>/g, \"\");\n\n                    }\n\n                    //  here go the callbacks\n                    self.options.afterExpand.call(currentElement);\n\n                }\n\n            }\n\n        }\n\n\n        /*\n            public function\n            truncate / hide original content\n        */\n        self.truncateContent = function(selector, btnPosition) {\n\n            let currentElements;\n\n            //  set specific element to expand or use current instance node\n            if (selector) {\n                currentElements = document.querySelectorAll(selector);\n            } else {\n                currentElements = self.options.elementsToTruncate;\n            }\n\n            for (let i = 0; i < currentElements.length; i++) {\n\n                const currentElement      = currentElements[i];\n                const currentContent      = currentElement.innerHTML;\n                const thisIndex           = currentElement.dataset.cuttrIndex;\n                const readMoreText        = (currentElement.dataset.cuttrReadmore) ? currentElement.dataset.cuttrReadmore : self.options.readMoreText;\n                const thisBtnPosition     = (btnPosition) ? btnPosition : self.options.readMoreBtnPosition;\n                const btnSelectorClass    = '.' + self.options.readMoreBtnSelectorClass;\n                const truncateLength      = (currentElement.dataset.cuttrLength) ? currentElement.dataset.cuttrLength : self.options.length;\n                const truncateEnding      = (currentElement.dataset.cuttrEnding) ? currentElement.dataset.cuttrEnding : self.options.ending;\n                let truncatedContent;\n                let btnExists;\n\n                //  hide content if its currently fully visible\n                if (self.options.contentVisibilityState[thisIndex]) {\n\n                    //  truncate content\n                    truncatedContent = truncateIt(currentElement, currentContent.trim(), truncateLength, truncateEnding);\n                    currentElement.innerHTML = truncatedContent;\n\n                    //  set visibility state\n                    self.options.contentVisibilityState[thisIndex] = false;\n\n                    //  read-more handling only if enabled\n                    if (self.options.readMore) {\n\n                        if (thisBtnPosition == 'inside')\n                            addReadMore(currentElement, true);\n\n                        //  check for button existence depending on btn position\n                        if (thisBtnPosition == 'after') {\n                            btnExists = currentElement.nextElementSibling;\n                        } else if (thisBtnPosition == 'inside') {\n                            btnExists = currentElement.querySelector(btnSelectorClass);\n                        }\n\n                        //  update button text\n                        if(btnExists)\n                            btnExists.innerHTML = readMoreText.replace(/<[^>]*>/g, \"\");\n\n                    }\n\n                    //  here go the callbacks\n                    self.options.afterTruncate.call(currentElement);\n\n                }\n\n            }\n\n        }\n\n\n        /*\n            public function\n            restore the element to a pre-init state\n        */\n        self.destroy = function(selector, btnPosition) {\n\n            //  expand original content\n            self.expandContent(selector, btnPosition);\n\n            let currentElements;\n\n            //  set specific element to expand or use current instance node\n            if (selector) {\n                currentElements = document.querySelectorAll(selector);\n            } else {\n                currentElements = self.options.elementsToTruncate;\n            }\n\n            for (let i = 0; i < currentElements.length; i++) {\n\n                let currentElement      = currentElements[i];\n                const currentContent      = currentElement.innerHTML;\n                const thisIndex           = currentElement.dataset.cuttrIndex;\n                const thisBtnPosition     = (btnPosition) ? btnPosition : self.options.readMoreBtnPosition;\n                const btnSelectorClass    = '.' + self.options.readMoreBtnSelectorClass;\n                let btnExists;\n\n                //  set visibility state\n                self.options.contentVisibilityState[thisIndex] = true;\n\n                //  remove read-more  if enabled\n                if (self.options.readMore) {\n\n                    if (thisBtnPosition == 'inside')\n                        addReadMore(currentElement, true);\n\n                    //  check for button existence depending on btn position\n                    if (thisBtnPosition == 'after') {\n                        btnExists = currentElement.nextElementSibling;\n                    } else if (thisBtnPosition == 'inside') {\n                        btnExists = currentElement.querySelector(btnSelectorClass);\n                    }\n\n                    //  remove button\n                    if(btnExists)\n                        btnExists.parentNode.removeChild(btnExists);\n                    //btnExists.remove();\n\n                }\n\n                //  remove element classes\n                currentElement.classList.remove(self.options.loadedClass);\n\n                //  remove truncate-element index from element\n                currentElement.removeAttribute(self.options.dataIndex);\n\n                //  reset current truncation instance\n                currentElement = null;\n\n            }\n\n        }\n\n\n        //utils\n        /*\n            shows console message\n        */\n        function showError(type, text){\n            window.console && window.console[type] && window.console[type]('Cuttr: ' + text);\n        }\n\n        init();\n        return self;\n    };\n    return Cuttr;\n}));\n\n\n/**\n * jQuery adapter for Cuttr.js 1.4.0\n */\nif(window.jQuery && window.Cuttr){\n    (function ($, Cuttr) {\n        'use strict';\n\n        // No jQuery No Go\n        if (!$ || !Cuttr) {\n            //window.cuttr_utils.showError('error', 'jQuery is required to use the jQuery Cuttr adapter!');\n            console.log('ERROR - jQuery is required to use the jQuery Cuttr adapter!');\n            return;\n        }\n\n        $.fn.Cuttr = function (options) {\n            return this.each((e, element) => {\n                options = $.extend({}, options, {'$': $});\n                if (!$.data(element, 'Cuttr')) {\n                    $.data(element, 'Cuttr', new Cuttr(element, options));\n                }\n            });\n        };\n    })(window.jQuery, window.Cuttr);\n}\n"]}